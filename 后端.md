### 1.Node.js 模块开发

```
在node.js中 每一个JavaScript就是一个模块
使用exports对象进行成员导出
使用require方法导入
```

```
导出exports
// a.js模块
let version = 1.0;
const sum = (n1, n2) => return n1 + n2;
exports.version = version;
exports.sum = sum;
```

```
导入require
// b.js模块导入
let a = require('./b.js');
console.log(a.version);
console.log(a.sum(10, 20));
```

```
导出的第二种方法module.exports
module.exports.version = version;
// 当module.exports 和 exports 所指的不是同一个对象时（不同的地址）以module.exports为准
```

### 2.node系统模块

#### 2.1 文件操作系统fs

```
// 获取文件模块
const fs = require('fs');
// 读取文件内容
fs.readFile('文件路径/文件按名次'[,'文件编码'], callback);
```

```
// 读取上一级css目录下中的base.css
fs.readFile('../css/base.css', 'utf-8', (err, doc) => {
	// 如果读取发生错误 参数err的值为错误对象否则err的值为null
	// doc参数为文件内容
	if (err == null) {
		console.log(doc);
	}
})
```

```
// 1.通过模块的名字fs对模块进行引用
const fs = require('fs');
// 2.通过模块内部readFile读取文件内容
fs.readFile('./01.helloworld.js', 'utf-8', (err, doc) => {
	// 如果文件读取出错err 是一个对象 包含错误信息
	// 如果文件读取正确 err 是 null
	// doc 是文件读取的结果
	console.log(err);
	console.log(doc);
})
```

##### 写入文件内容

```
fs.writeFile('文件路径/文件名称', '数据', callback);
// callback 参数err err 为null 没有错误 
```

```
// 1. 获取文件模块
const fs = require('fs');
// 2. 利用文件模块写入文件
fs.writeFile('./demo.txt', '写入的内容', err => {
	if (err !== null) {
		console.log(err);
		return;
	}
	console.log('文件内容写入成功');
})
```

#### 2.2  系统模块path 路径操作

```
不同操作系统的路径分隔符不统一
Window 上是 \  或 /
Linux 上是 /
```

##### 路径拼接语法

```
path.join('路径', '路径', ...);
```

```
// 导入path模块
const path = require('path');
// 路径拼接
let finialPath = path.join('it', 'a', 'b', 'index.html');
console.log(finialPath); // it\a\b\index.html (window系统自动识别 \ ) (linux 系统识别 / )
```

#### 2.3 第三方模块

```
第三方模块存在的两种形式
1. 以js文件的形式存在， 提供实现项目功能的API接口
2. 以命令行工具形式存在，辅佐项目开发
下载和卸载第三方模块
下载 npm install 模块名称
卸载 npm unintall 模块名称
```

```
安装第三方模块 nodemon
命令行工具 辅助项目开发
使用步骤
1.使用 npm install nodemon -g  // 全局下载
2.在命令行 用 nodemon 代替 node

// ctrl + c 停止
```

```
第三方模块 nrm （npm下载地址切换工具）
npm默认的下载地址在国外，国内下载速度慢
使用步骤
1. 使用 npm install nrm -g 下载
2. 查询可用下载地址列表 nrm ls
3. 切换npm 下载地址 nrm use 下载地址名称
```

#### gulp使用

```
基于node平台开发的前端构建工具
用机器代替手工 提高开发效率
能做什么
1. 项目上线 HTML CSS JS 文件压缩合并
2. 语法转换（es6 less）
3.公共文件抽离
4. 修改文件浏览器自动刷新
```

```
使用
1. 使用 npm install gulp 下载gulp库文件
2. 在项目根目录下建立 gulpfile.js 文件
3. 重构项目的文件结构src目录放置源代码文件 dist目录放置构建后的文件
4. 在glupfile.js文件中编写任务
5. 在命令行工具执行gulp任务
```

```
gulp中的方法
gulp.src(): 获取任务要处理的文件
gulp.dest(): 输出文件
gulp.task(): 建立gulp任务
gulp.watch(): 监控文件的变化
```

```
下载 gulp的命令行工具
npm install gulp-cli -g
```

```
使用
// 引入gulp模块
const gulp = require('gulp');
// 使用gulp.task() 建立任务
// 1. 任务的名称
// 2. 任务的回调函数
gulp.task('first', () => {
	// 使用gulp.src获取要处理的文件
	gulp.src('./src/css/base.css')  //没有分号
        // 文件输出
        .pipe(gulp.dest('dist/css'));
 })
```

#### gulp插件

```
gulp-htmlmin : html文件压缩
gulp-csso : 压缩css
gulp-babel : JavaScript语法转换
gulp-less : less语法转换
hulp-uglify : 压缩混淆 JavaScript
gulp-file-include : 公共文件包含
browsersync 浏览器实时同步
```

```
glup-htmlmin: html 文件压缩
1. 在命令行 下载 gulp-htmlmin
	npm install gulp-htmlmin
2. 在编译器中引入gulp-htmlmin
const gulp = require('gulp');
const htmlmin = require('gulp-htmlmin');

gulp.task('htmlmin', () => {
	gulp.src('./src/*.html')
	 // 压缩html文件中的代码
	 .pipe(htmlmin({collapseWhitespace: true}))  // true 压缩空格 false不压缩空格
	 // 输出文件
	 .pipe(gulp.dest('dist'));
})

// 3.在命令行执行 
gulp htmlmin
```

```
gulp-file-include 提取html公共文件 要写在压缩文件之前
1. 在命令行 下载 gulp-file-include
	npm install gulp-file-include
把html公共部分提取出来方法一个新的文件中
2. 在编译器中引入 gulp-file-include
const gulp = require('gulp');
const fileinclude = require('gulp-file-include');
// 在每一个html文件中的头部写 @@include('引入提取出的公共html文件')
gulp.task('fileinclude', () => {
	gulp.src('./src/*.html')
	.pipe(fileinclude())
	.pipe(htmlmin({collapseWhitespace: true})) //压缩
})

3. 在命令行执行
gulp fileinclude
```

```
css任务
1. less语法转换
2. css代码压缩

1. 在命令行下载 gulp-less
 npm install gulp-less  // 下载转换less语法
 npm install gulp-csso // 下载压缩css
2.引入gulp-less
 const gulp = require('gulp');
 const less = require('gulp-less');
 // 建立gulp任务
 gulp.task('less', () => {
 	// 获取文件 参数为数组可获取多个文件
 	gulp.src(['./css/*.css', './css/*.less'])
 	// 把less文件转化未css文件
 	.pipe(less())
 	// 压缩css文件
 	.pipe(csso())
 	// 输出文件
 	.pipe(gulp.dest('dist/css'));
 })
```

```
javascript 任务
1. es6语法转换
2. javascript压缩

// 1. 在命令行下载 gulp-babel  gulp-uglify
// 2.引入文件
 const gulp = require('gulp')
 const babel = require('gulp-babel');
 const jsmin = require(' gulp-uglify');
 
 gulp.task('jsmin', () => {
 	gulp.src('../js/*.js')
 	.pipe(babel({
 	// 它可以判断代码的运行环境 将代码转化为运行环境支持的代码
 		presets: ['@babel/env']
 	})
 	.pipe(uglify())
 	.pipe(gulp.dest('dist/js'));
 })
```

```
复制文件夹
gulp.task('copy', () => {
	gulp.src('./src/images/*')
	.pipe(gulp.dest('dist/images'));
	gulp.src('./src/lib/*')
	.pipe(gulp.dest('dist/lib'))
})
```

```
构建任务
gulp.task('default', ['htmlmin', 'cssmin', 'jsmin', 'copy']);

在命令行输入 gulp
```

#### node_modules文件夹的问题

```
1. 文件夹及文件过多过碎，当我们将项目整体拷贝给别人的时候，传输速度会很慢很慢
2. 复杂的模块依赖关系需要被记录， 确保模块的版本和当前保持一致 否者会导致运行时报错
```

```
package.json文件
描述文件 
使用 npm init -y 生成 
```

#### 项目依赖

```
在项目开发阶段和线上运行阶段， 都需要依赖的第三方包 称为项目依赖
使用 npm install 包名命令下载的文件会默认被添加到package.json 文件的 dependencies 字段中
{
	"dependencies": {
		"jquery": "^3.3.1"
	}
}
```

```
开发依赖
在项目的开发阶段需要依赖 线上运营阶段不需要依赖的第三方包 称为开发依赖
使用 npm install 包含--save-dev命令将包添加到package.json文件的devDependencies字段中
{
	"devDependencies": {
		"gulp": "^3.9.1"
	}
}
```

```
npm install 下载所有文件
npm install --production 下载项目依赖文件
```

#### 2.4 模块查找规则

##### 2.4.1模块拥有路径没有后缀时

```
require('./find');
1. require方法根据模块路径查找， 如果时完整路径，直接引入模块
2. 如果模块后缀省略,先找同名js文件再找同名js文件夹
3. 如果找到同名文件夹， 找文件夹中的index.js
4. 如果文件夹中没有index.js就会去当前文件夹的package.js文件中查找main选项中的入库文件
5. 如果找指定的入口文件不存在或者没有指定入口文件就会报错，模块没有被找到
```

##### 2.4.2 模块没有路径且没有后缀

```
require('find');
1. Node.js会假设它为系统模块
2. Node.js会去node_modules文件夹中
3. 首先看是否有改名字的js文件
4. 再看是否有改名字的文件夹
5. 如果是文件夹看里面是否有index.js
6. 如果没有index.js查看文件夹中的package.json中的main选项确定模块的入口文件
7. 否者找不到报错
```

### 3. 服务器端

#### 3.1 URL

```
传输协议：//服务器IP或域名：端口/资源所在位置标识
```

#### 3.2 创建web服务器

```
// 引入http系统模块
const http = require('http');
// 创建web服务器
const app = http.createServer();
// 当客户端发送请求时
app.on('require', (req, res) {
	// 响应
	res.end('<h1>123<h1>');
})
// 监听端口
app.listen(3000);
console.log('服务器已启动，监听3000端口，请访问localhost:3000')
```

#### 3.3 请求报文

```
1. 请求方式
GET 请求数据
POST 发送数据
2. 请求地址
app.on('request', (req, res) {
	req.headers // 获取请求报文 // 获取具体的报文信息 req.headers['Accept']
	req.url // 获取请求地址
	req.method // 获取请求方式
})
```

#### 3.3 响应报文

```
1. HTTP状态码
200 请求成功
404 请求的资源没有被找到
500 服务器端错误
400 客户端请求有语法错误
```

```
2 内容类型
text/html
text/css
application/javascript
image/jpeg
application/json
```

```
写头部
res.writeHead(200, {
	'content-type': 'text/html;chraest=utf8'
})
// 第一个参数状态码 
// 第二个参数对象包含了头部信息
```

#### 3.4 请求参数

```
GET请求参数
参数被放置再浏览器地址中,例如 http://localhost:3000/?name=zhangsan&paw=123

// 获取处理url处理的模块
const url = require('url');
// url解析方法
// 参数1 要解析的url地址
// 参数2 将查询参数解析成对象形式
url.parse(req.url, true);
// 获取解析的对象
url.parse(req.url, true).query;
```

```
post请求参数是通过事件的方式接收的
data 当请求参数传递的时候触发data事件
end当参数传递完成的时候触发end事件

// 导入系统模块querystring用于将HTTP参数转换为对象格式
const querystring = requery('querystring');
// 引入http系统模块
const http = require('http');
// 创建web服务器
const app = http.createServer();
// 当客户端发送请求时
app.on('require', (req, res) {
	let postData = '';
	// 监听参数传输事件
	req.on('data', chunk => postData += chnk;);
	// 监听参数传输完毕事件
	req.on('end', () => {
	// 转换为对象
		console.log(querystring.parse(postData));
	})
})
// 监听端口
app.listen(3000);
console.log('服务器已启动，监听3000端口，请访问localhost:3000')

```

#### 3.5 路由

```
// 1. 引入系统模块http
// 2. 创建网站服务器
// 3. 为网站服务器对象添加请求事件
// 4. 实现路由功能
	// 1. 获取客户端的请求事件
	// 2. 获取客户端的请求地址
const http = require('http');
const url = require('url');
const app = http.createServer();

app.on('request', (req, res) => {
	res.writeHead(200, {
	'content-type': 'text/index; charset=utf8'
	})
	// 获取请求方式 转换为小写
	const method = req.method.toLoewrCase();
	// 获取请求地址
	const pathname = ul.prase(req.url).pathname;
	if (method == 'get') {
		if (pathanme == '/' || pathname == '/index') {
			res.end('欢迎来到首页');
		} else if (pathname == '/list'){
			res.end('欢迎来到列表也');
		} else {
			res.end('没有找到');
		}
	} else if (method == 'post') {

	}
})
```

#### 3.6 静态资源

```
服务器端不需要处理， 可以直接响应给客户端的资源就是静态资源，例如 css javascript image html文件
```

#### 3.7 动态资源

```
相同的请求地址不同的响应资源， 这种资源就是动态资源
http://www.it.cn/article?id=1
http://www.it.cn/article?id=2
```

```
// 获取静态文件
// 引入http模块
const http = require('http');
// 引入url模块
const url = require('url');
// 引入path模块
const path = require('path');
// 引入fs模块
const fs = require('fs');
// 引入第三方插件 mime 用于获取文件的类型 // 需要下载
const type = require('mime');
// 创建web服务器
const app = http.createServer();
// 响应客户端的事件
app.on('request', (rep, res) => {
	// 获取客户端请求的路径
	let pathname = url.parse(rep.url).pathname;
    // 设置默认的浏览地址为首页地址
    pathname = pathname == '/' ? '/default.html' : pathname;
	// 获取客户端请求文件的绝对路径
	let realPath = path.join(__dirname, '文件夹的名字', pathname);
	// 获取文件的类型 包含引入文件
	let type = mime.getType(realPath);
	// 文件读取
	fs.readFile(realPath, (err, result) => {
		if (err != null) {
			res.writeHead(404, {
				'content-type': 'text/html;charset=utf8'
			})
			res.end('文件读取错误');
			result;
		}
		res.writeHead(200, {
			'content-type': type
		})
		res.end(reault);
	})
})
// 监听端口
app.listen(3000);
console.log('响应成功');
```

#### 3.8同步API 和 异步API

```
同步api可以从返回值中拿到api执行的结果，但是异步api是不可以的
// 同步
function sum(n1, n2) {
	return n1 + n2;
}
const reault = sum(10, 20);

// 异步
function getMsg() {
	setTimeout(function () {
		return {msg: 'hello Node.js'}
	}, 2000);
}
const msg = getMsg();
console.log(msg); // undefined
// 原因： 定时器是异步 再执行的过程中 getMsg（） 函数没有返回值 默认返回 undefined 
```

```
利用回调函数决解异步不能拿到返回值 参数为回调函数 把结果放到回调函数中 同步执行完 回调函数异步执行拿到结果

function getMsg(callback) {
	setTimeout(function () {
		callback({
			msg: 'hello node.js'
		});
	}, 2000);
}
getMsg(function (data) {
	console.log(data);
})

```

#### 3.9 Promise

```
Promise出现的目的是解决Node.js异步变成中回调地狱的问题
```

```
const fs = require('fs');
let promise = new Promise((resolve, reject) => {
	fs.readFile('./100.txt', 'uft8', (err, result) => {
		if (err != null) {
		// 如果文件调用失败 调用第二个参数是一个函数 传回错误对象
			reject(err);
		} else {
		// 如果文件调用成功 调用第一个参数是一个函数 传回文本对象
			resolve(result)
	})
})
// 调用promise的方法接收返回的参数
promise.then((result) => {
	console.log(result);
}).catch((err) => {
	console.log(err);
}); // 链式编程

```

```
Promise出现的目的是解决Node.js异步变成中回调地狱的问题

const fs = require('fs');
function p1() {
	return new Promise((resolve, reject) => {
		fs.readFile('./1.txt', 'utf8', (err, result) => {
			if (err != null) {
		// 如果文件调用失败 调用第二个参数是一个函数 传回错误对象
			reject(err);
		} else {
		// 如果文件调用成功 调用第一个参数是一个函数 传回文本对象
			resolve(result)
		})
	})
}
function p2() {
	return new Promise((resolve, reject) => {
		fs.readFile('./2.txt', 'utf8', (err, result) => {
			if (err != null) {
		// 如果文件调用失败 调用第二个参数是一个函数 传回错误对象
			reject(err);
		} else {
		// 如果文件调用成功 调用第一个参数是一个函数 传回文本对象
			resolve(result)
		})
	})
}
function p3() {
	return new Promise((resolve, reject) => {
		fs.readFile('./3.txt', 'utf8', (err, result) => {
			if (err != null) {
		// 如果文件调用失败 调用第二个参数是一个函数 传回错误对象
			reject(err);
		} else {
		// 如果文件调用成功 调用第一个参数是一个函数 传回文本对象
			resolve(result)
		})
	})
}
p1().then((r1) => {
	console.log(r1);
	return p2();
}).then((r2) => {
	console.log(r2);
	return p3();
}).then((r3) => {
	console.log(r3);
})
```

#### 4.0 异步函数（es7 简化Promise）

```
// 1.异步函数就是在普通函数前面加上 async 关键字
// 2.异步函数默认的返回值是promise对象
// 3. 在异步函数内部使用 throw 关键字进行错误的抛出
// 4. await 关键字
// 它只能出现在异步函数中
// await 它可以暂停异步函数的执行 等待promise对象返回结果在向下执行
async function fn() {
	throw '出错了';
	return 123;
}
```

```
async function p1() {
	return 'p1';
}
async function p2() {
	return 'p2';
}
async function p3() {
	return 'p3';
}
asycn function run() {
	let r1 = await p1();
	let r2 = await p2();
	let r3 = await p3();
	console.log(r1);
	console.log(r2);
	console.log(r3);
}
run();
```

```
async 关键字
1. 异步函数定义前加async 普通函数变成异步函数
2. 异步函数默认的返回值是promise对象
3. 在异步函数内部使用return 关键字进行结果返回 结果会被包裹在promise对象中 return 关键字代替了 resolve 方法
4. 在异步函数内部使用throw 关键字抛出程序异常
5. 调用异步函数在链式调用then方法获取异步函数执行结果
6. 调用异步函数在链式调用catch方法获取异步函数执行的错误信息
```

```
await关键字
1. await关键字只能出现在异步函数中
2. await promise await豁免只能写promise对象 写其他类型的API是不可以的
3. await关键字可以暂停异步函数向下执行 直到promise返回结果
```

```
使用异步函数简化js异步变成中回调地狱的问题

const fs = require('fs');
// 改造现有异步函数 API 让其返回promise对象 从而支持异步函数语法
cons promisity = require('util').promisity;
// 调用promisity 方法改造现有的异步API 让其返回promise对象
const readFile = promisity(fs.readFile);

async function run() {
	let r1 = await readFile('./1.txt', 'utf8');
	let r2 = await readFile('./2.txt', 'utf8');
	let r3 = await readFile('./3.txt', 'utf8');
	console.log(r1);
	console.log(r2);
	console.log(r3);
}
run();
```

#### 4.1 node.js 的方法

```
在Node中全局对象是global
Node中全局对象有以下方法
console.log()  在控制台输出
setTimeout() 设置超时定时器
clearTimeout() 清除超时定时器
setInterval() 设置间歇定时器
clearInterval() 清除间歇定时器
```

### 4. MongoDB

```
使用mongoose插件 提供的 connect方法即可连接数据库
const mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/playground')
.then(() => console.log('数据库连接成功'))
.catch(err => console.log('数据库连接失败));
```

#### 4.1 创建集合

```
创建集合分为两步 一是对集合设定规则 二是创建集合 创建mongoose.Schema()构造函数的实例即可创建集合
```

```
// 创建集合规则
const courseSchema = new mongoose.Schema({
	name: String,
	author: String,
	isPublished: Boolean
});
// 创建集合并应用规则
const Course = mongoose.model('Course', courseSchema);  // 集合名Course 首字母大写 在数据库中显示 courses 返回的是一个构造函数
```

```
连接数据库并添加数据
// 引入mongoose模块
const mongoose = require('mongoose');
// 连接数据库
mongoose.connect('mongodb://localhost/palyground', { useNewUrlParser: true, useUnifiedTopology: true })
.then(() => {
	console.log('数据库连接成功');
})
.catch(err => {
	console.log('数据库连接失效');
});
// 创建集合规则
const courseSchema = new mongoose.Schema({
	name: String,
	author: String,
	isPublished: true
});
// 利用集合规则 创建集合 返回一个构造函数
const Course = mongoose.model('Course', sourseSchema);
// 写数据
const course = new Course({
	name: '数学',
	author: '张三',
	isPublished: true
});
// 保存数据
course.save();
```

```
// 写数据的另一种方法
Course.create({name: '数学', author: '李四', isPublished: true}, (err, doc) => {
	// 错误对象
	console.log(err);
	// 当前插入的文档
	console.log(doc);
})


// 因为create方法返回的是一个Promise对象
// 所以可以写
Course.create({name: '数学', author: '李四', isPublished: true}).then(doc => {
	console.log(doc);
}).catch(err => {
	console.log(err);
});
```

#### 4.2mongoDB 数据库导入数据

```
mongoimport -d 数据库名称 -c 集合名词 --file 要导入的数据文件
```

#### 4.3 查询文档

```
// 根据条件查询文档 (条件为空则查找所有文档)
// find() 方法返回的是一个promise对象
// 返回一组数 一个数组包裹
Course.find().then(result => console.log(result));

// 通过_id查找
Course.find({_id: '5c09f1e5aeb04b22f8460965'}).then(result => {
	console.log(result);
});

// findOne()方法返回一条文档 是 对象 默认返回第一条文档
User.find().then(result => {
	console.log(result);
})

// 条件查询
User.find({name: '李四'}).then(result => {
	console.log(result);
});
```

```
// 匹配大于 小于
User.find({age: {$gt: 20, $lt: 50}}).then(result => {
	console.log(result);
});
// 匹配包含
User.find({hobbies: {$in: ['敲代码']}}).then(result => {
	conasole.log(result);
});
// 选择要查询的字段 _id默认字段 如果不要的字段前面加-
User.find().select('name email -_id').then(result => {
	console.log(result);
})
// 将数据按照年龄进行排序 默认升序排列
User.find().sort('age').then(result => {
	console.log(result);
})
// 加-降序排列
User.find().sort('-age').then(result => {
	console.log(result);
})
// skip跳过多少条数据 limit限制查询数量
User.find().skip(2).limit(2).then(result => console.log(result))

```

#### 4.4 删除文档

```
// 删除单个
// 返回被删除的文档
// 如果有多个匹配 删除符合条件的第一个文档
Course.findOneAndDelete({}).then(result => {
	console.log(result);
})

// 删除多个文档
// 参数为空 删除集合所用文档
// 返回值是一个对象 有两个参数 n代表删除几条数据 ok为1代表删除操作成功
User.deleteMany({}).then(result => {
	console.log(result);
})
```

#### 4.5 更新文档

```
// 更新集合中的文档(更新一个)
// 返回一个对象 三个参数 参数1 n要修改的文档个数 参数2 nModified 修改成功的文档个数 ok 为1修改成功
User.updataOne({name: '李四'}, {name: '李五'}).then(result => {
	console.log(result);
})


// 更新多个文档
// 返回一个对象 三个参数 参数1 n要修改的文档个数 参数2 nModified 修改成功的文档个数 ok 为1修改成功
// 第一个参数为空 把所有文档的age改为30
User.UpdataMany({}, {age: 30}).then(result => {
	console.log(result);
});
```

####  4.6 mongoose的验证

```
const postSchema = new mongoose.Schema({
	titile: {
		// 类型
		type: String,
		// title这个文档必须写 不写报错
		required: true,
		// 最小字符长度
		minlength: 2,
		// 最大字符长度
		maxlength: 5,
		// 去除两端的空白
		trim: true
	}
});

// 报错也可以自己定义
const postSchema = new mongoose.Schema({
	titile: {
		// 类型
		type: String,
		// title这个文档必须写 不写报错
		required: [true, '标题必须传入'],
		// 最小字符长度
		minlength: [2, '最小字符长度2'],
		// 最大字符长度
		maxlength: [5, '最大字符长度5'],
		// 去除两端的空白
		trim: true
	}
});
```

```
常用的验证规则
required: true 必传字段
minlength: 3 字符最小长达
maxlength: 20 字符最大长度
min: 2 数字最小为2 
max: 100 数字最大为100
enum: ['html', 'css', 'javascript', 'node.js'] 枚举 列举出当前字符拥有的值
trim: trim 去除字符串两边的空格
default: 默认值
validate: 自定义验证器
// 
validate: {
	validator: v => {
		// 返回一个布尔值 false验证失败 true验证成功
		return v && v.length > 4;
	}
	// 自定义错误信息
	message: '传入的值不符合验证规则';
}
```

#### 4.7 获取错误信息

```
.catch(error => {
	// 获取错误信息
	const err = error.errors
	// 循环错误信息对象
	for (var attr in err) {
		// 将错误信息打印到控制台中
		console.log(err[attr]['message']);
	}
})
```

#### 4.8 集合关联

```
不同集合的数据之间是有关系的
使用id对集合进行关联
使用populate方法进行关联集合查询
```

```
// 用户集合规则
const userSchema = new mongoose.Schema({
	name: {
		type: String,
		required: true
	}
});
// 文章集合规则
const postSchema = new monoose.Schema({
	title: {
		type: String
	},
	author: {
	// 作者的信息在用户集合中存的type是一个_id类型
		type: mongoose.Schema.Types.ObjectId,
	// 关联的集合
		ref: 'User'
	}
});
// 创建用户集合
const User = mongoose.model('User', userSchema);
// 创建文章集合
const Post = mongoose.model('Post', postSchema);

// 创建用户
User.create({name: 'kk'}).then(result => {
	console.log(result);
})
// 创建文章
Post.create({title: '123', author: '用户集合的_id'}).then(result => {
	console.log(result);
})
// 联合查询
Post.find().populate('author').then((err, result) => {
	console.log(result);
})
```

### 5. 模板引擎

```
art-template模板引擎
在命令行中下载 npm install art-template
使用const template = require('模板路径', 数据);
```

```
// 引入模板引擎
const template = require('art-template');
// 引入path用来拼接绝对地址
const path = require('path');
// 拼接绝对地址
const views = path.join(__dirname, 'view', 'index.art');
// 利用template方法是用来拼接字符串
	// 参数1 模板路径 绝对路径
	// 参数2 在模板中显示的数据 对象类型
	// 返回拼接好的字符串
const html = template(views, {
	name: '张三',
	age: 20
})
```

#### 5.1条件判断

```
// 标准语法
{{if 条件}}.....{{/if}}
{{if 条件}}......{{else if 条件2}}.....{{/if}}

// 原始语法
<% if (value) {%>.....<% } %>
<% if (value) {%>......<% else if (v2) {%>......<% } %>
```

#### 5.2 循环

```
标准语法： {{each 数据}}  {{/each}}
原始语法： <% for() {%>   <% } %>

标准语法
{{each target}}
	{{$index}} // 获取索引
 	{{$value}} // 获取值
 {{/each}}
 原始语法
 <% for (var i = 0; i < target.length; i++) { %>
 	<%= i %> //输出索引
 	<%= target[i] %> // 输出索引值
 <% } %>
```

#### 5.3 子模版

```
使用子模版可以将网页公共区域（头部 底部）抽离到单独的文件中
```



```
标准语法： {{include '模板'}}
原始语法： <%include('模板') %>

标准语法
{{include './header.art'}}
原始语法
<% include('./header.art') %>
```

#### 5.4 模板继承

```
// layout.art文件
<html>
	<head>
		<meat charset="uft-8">
		<title>HTML骨架模板</title>
		{{block 'head'}} {{/block}}
	</head>
	<body>
		{{block 'content'}} {{/block}}
	</body>
<html>
```

```
继承模板并填充内容
// index.art文件
{{extend './layout.art'}}
{{block 'head'}} <link rel="stylesheet" href="custom.css"> {{/block}}
```

#### 5.5 模板配置

```
1. 向模板中导入变量
template.defaults.imports.变量名 = 变量值;
2. 设置模板根目录
template.defaults.root = 模板目录;
// template.defaults.root = path.join(__dirname, 'view');
3. 设置模板默认后缀
template.defaults.extname = '.art';
```

```
const html = template('06', {
	time: now Date()
})
```

#### 5.6 第三方模块 router(实现路由)

```
// 功能实现路由 npm install router
使用步骤
0. 引入router模块
const getRouter = require('router');
1. 获取路由对象
const router = getRouter();
2. 调用路由对象提供的方法创建路由
router.get('/test', (req, res) => {
	res.end('test');
})
3. 启动路由 使路由生效 (app 是服务器)
app.on('request', (req, res) => {
	// 启动路由 三个参数 第三个必写 回调函数
	router(req,res, () => {});
})
```

#### 5.7 第三方模块 serve-static(实现静态资源访问服务)

```
功能： 实现静态资源访问服务
使用步骤： 
1. 引入serve-static模块获取创建静态资源服务功能的方法
2.调用方法创建静态资源访问并指定静态资源服务目录
3. 启动静态资源服务功能
```

```
const serveStatic = require('serve-Static');
const serve = serveStatic('public');
server.on('request', (req, res) => {
// 启动访问服务 三个参数 第三个必写 回调函数
	serve(req, res, () => {});
})
```

#### 5.8 第三方模块 dataformat (格式化时间)

```
功能： 格式化时间
```

### 6.express框架

#### 6.1 入门

```
下载express框架 npm install express
引入express
const express = require('express');
// 创建网站服务器
const app = express();
// 路由
app.get('/', (req,res) => {
	// send()
	// 1.send方法内部会自动检测响应内容的类型
	// 2. send方法会自动设置http状态码
	// 3. send方法会自动设置响应的内容类型及编码
	res.send('hello express');
})
app.get('/list', (req, res) => {
	res.send({
		name: '张三',
		age: 12
	}) // 在页面响应json数据
})
// 监听端口
app.listen(3000);
console.log('网站服务器启动成功')
```

#### 6.2 中间件

```
中间件就是一堆方法 可以接受客户端的请求 可以对请求做出响应 也可以将请求继续交给下一个中间件继续处理
中间件主要由两部分构成 中间件方法  请求处理函数
中间件方法由express提供 负责拦截请求 处理函数由开发人员提供 负责请求处理
```

```
app.get('请求路径', '处理函数') //接收并处理get请求
app.post('请求路径', '处理函数') // 接收并处理post请求
```

```
针对同一个请求设置多个中间件
app.get('/requsest', (req, res, next) => {
	req.name = '张三';
	next();
})
app.get('/request', (req, res) => {
	res.send(req.name);
})
```

#### 6.3 app.use() 中间件 （app是服务器）

```
app.use() 匹配所有请求方式
app.use((req, res, next) => {
	console.log(req.url);
	next();
})
// 第一个参数可以传入请求地址  匹配请求该地址的所有方法
app.use('/admin', (req, res, next) => {
	console.log(req.url);
	next();
})
```

#### 6.4 中间件的应用

```
1. 路由保护，客户端在访问需要登录页面时，可以先使用中间件判断用户登陆状态， 用户如果未登陆， 则拦截请求，直接响应禁止用户进入需要登录的页面
app.use('/admin', (req, res, next) => {
	// 设置一个登陆状态
	let isLogin = false;
	if (isLogin) {
		next();
	} else {
		res.send('您还没有登陆');
	}
})
2. 网站维护公告，在所有路由的最上面定义接收所有请求的中间件， 直接为客户端做出响应， 网站正在维护中
app.use((req, res, next) => {
	res.send('网站正在维护...');
})
3. 自定义404页面 放在最下面
app.use((req, res, next) => {
	res.states(404).send('您访问的页面不存在');
})
```

#### 6.5 错误处理中间件

```
在程序执行过程中，不可避免的出现一些无法预料的错误，比如文件读取失败 数据库连接失败 错误处理中间价是一个集中处理错误的地方
// 只能自动捕获同步错误
app.get('/test', (req, res, next) => {
 	// 同步抛出错误
	throw new Error('程序发生了未知错误');
});
app.use((err, req, res, next) => {
	res.status(500).send(err.message);
})

// 异步错误
app.get('/index', (req, res) => {
	fs.readFile('./demo.txt', 'utf8', (err, result) => {
		if (err != null) {
		// 异步 手动抛出错误
			next(err);
		} else {
			res.send(result);
		}
	})
});
app.use((err, req, res, next) => {
	res.status(500).send(err.message);
})
```

#### 6.3 错误捕获

```
try catch 可以捕获异步函数以及其他同步代码在执行过程中的错误 但是不能捕获其他类型API发生的错误
app.get('/', async (req, res, next) => {
	try {
		await User.find({name: '张三'})
	} catch(ex) {
		next(ex);
	}
})
// try 捕获错误 发生错误执行catch 否则执行catch后面的
```

#### 6.4 构建模块化路由

```
const express = require('express');
// 创建服务器
const app = express();
// 创建路由对象
const home = express.Router();
// 将路由和请求路径进行匹配
app.use('/home', home);
// 在home路由下在创建路由
home.get('/index', () => {
	//   /home/index
	res.send('欢迎来到博客展示页面')
});
```

```
构建模块化路由
// home.js
const home = express.Router();
// 在home路由对象下挂在二级路由
home.get('/index', () => {
	res.send('欢迎来到博客展示页面');
})
module.exports = home;
```

```
// admin.js
const admin = express.Router();
// 在admin路由对象下挂在二级路由
admin.get('/index', () => {
	res.end('欢迎来到博客管理页面');
});
module.exports = admin;
```

```
// app.js
const home = require('./router/home.js');
const admin = require('./router/admin.js');
// 分别为home和admin路由对象匹配路径
app.use('/home', home);
app.use('/admin', admin);
```

#### 6.5 GET参数的获取

```
Express框架中使用req.query即可获取GET参数， 框架内部会将GET参数转换为对象并返回
```

```
// 接收地址栏中问号后面的参数
// 例如 http://localhost:3000/?name=zhangsan&age=30
app.get('/', (req, res) => {
	console.log(req.query); // {"name":"zhangsan", "age": "30"}
})
```

#### 6.6 POST参数的获取 body-parser第三方包

```
Express中接收post请求参数需要借助第三方包 body-parser
// 下载body-parser
// 引入body-parser
const bodyParser = require('body-parser');
// 拦截所有请求
// extended: false 方法内部使用querystring模块处理请求参数的格式
// extended: true 方法内部使用第三方模块qs处理请求参数的格式
app.use(bodyParser.urlencoded({extended: false}));
app.post('/add', (req, res) => {
	// 接收post请求参数
	// 使用req.body接收请求参数
	res.send(req.body);
})
```

#### 6.5 Express路由参数

```
// 在服务端通过:
app.get('/find:id/:name', (req, res) => {
// 接收参数req.params
	console.log(req.params); // {"id": "123", "name": "zhangsan"}
})
// 在浏览器
localhost:3000/find/123/zhangsan
```

#### 6.6 静态资源的处理

```
通过Express内置的express.static可以方便的托管静态文件 例如img css javascript
app.use(express.static(path.join(__dirname, 'public')));
现在， public目录下面的文件就可以访问了
http://localhost:3000/images/kitten.jpg
```

#### 6.7 模板引擎

```
为了时art-template 模板引擎能够更好的和Express框架配合 模板引擎官方在原art-template模板引擎的基础上分装了express-art-trmplate
使用 npm install atr-template express-art-template
```

```
const express = require('express');
const path = require('path');
const app = express();
// 1.告诉express框架使用什么模板引擎渲染什么后缀的模板文件
	// 参数1 模板后缀
	// 参数2 使用什么模板引擎
app.engine('art', require('express-art-template'));
// 2. 告诉express模板存放在什么位置
// 第一个参数固定
app.set('views', path.join(__dirname, 'views'));
// 3.告诉express框架模板的默认后缀是什么
app.set('view engine', 'art');

app.get('/index', (req, res) => {
// 渲染模板
	//1. 拼接模板路径
	//2. 拼接模板后缀
	//3. 哪一个模板和哪一个数据进行拼接
	//4. 把拼接结果响应给客户端
	res.render('index', {
		msg: 'message'
	})
})
```

#### 6.8 app.locals 对象

```
将变量设置到app.locals对象下面， 这个数据在所有模板中都可以获取到
```

```
app.locals.user = [{
	name: '张三',
	age: 17
},{
	name: '李四',
	age: 20
}]
```

#### 6.9 密码加密 bcrypt

```
哈希加密是单层加密方式： 1234 => abcd
在机密的密码中加入随机字符串可以增加密码被破解的难度
使用
// 导入bcrypt
const bcrypt = require('bcrypt');
// 生成随机字符串 gen => generate 生成saltyan盐
let salt = await bcrypt.genSalt(10);
// 使用随机字符串对密码进行加密
let pass = await bcrypt,hash('密文密码', salt);


// 使用随机字符串对密码进行加密
let isEqual = await bcrypt.compare('明文密码', '加密密码');
```

```
bcrypt依赖的其他环境
1. python 2.x
2. node-gyp
 npm install -g node-gyp
3. windows-build-tools
	npm install --global --production windows-build-tools
```

#### 6.10 cookie 与 session

```
cookie: 浏览器在电脑硬盘中开辟的一块空间，主要供服务器端存储数据
1. cookie中的数据是以域名形似进行区分的
2. cookie中的数据是有过期时间的，超过时间数据会被浏览器自动删除
3. 客户端第一次访问服务器端 服务器端会生成cookie存储在客户端
3. 再次访问服务器端 cookie中的数据会随着请求自动发送到服务器端
```

```
session: 实际就是一个对象，存储在服务器端的内存中，在session对象中也可以存储多条数据，每一条数据都有一个sessionid作为唯一标识
```

```
客户端 将邮箱地址和密码 发送到客户端 客户端验证请求参数生成sessionid 将sessionid存储在客户端的cookie中
客户端再次请求 将cookie中的数据传送到服务器 服务器获取cookie中的sessionid 验明正身 响应只有用户登录后才能获取的数据
```

#### 6.11 express-session

```
在node.js中需要借助express-session实现session功能
const session = require('express-session');
app.use(session({secret: 'secret key'}));
```

#### 6.12 express中的重定向

```
res.redirect('/admin/user');
```

#### 6.13 清除session 和cookie

```
// 实现退出路由
admin.get('/logout', (req, res) => {
   // 删除session
   req.session.destroy(function () {
       // 清除cookie
       res.clearCookie('connect.sid');
       // 重定位
       res.redirect('/admin/login');
   })
})
```

#### 6.14 第三方模块 Joi

```
javaScript对象的规则描述语言和验证器
```

```
const Joi = require('joi');
// 创建规则
const schema = {
	// string() 字符串 alphanum() 字符串是字母或数字 min(3)字符串最小长度 max()字符串最大长度
	// required()必写  error(new Error('错误信息')) 自定义错误
	username: Joi.string().alphanum().min(3).max(30).required().error(new Error('错误信息')),
	// regex(/正则表达式/) 匹配正则表达式
	password: Joi.string().regex(/^[a-zA-Z0-9]{3,30}$/),
	// 既可以是字符串类型又可以是数字类型
	access_token: [Joi.string(), Joi.numbre()],
	// integer() 整数
	birthyear: Joi.numbre().integer().min(1900).max(2013),
	// email() 邮箱类型
	email: Joi.string().email()
}
```

```
实施验证
// 参数1 要验证对象
// 参数2 验证规则
// 返回一个promise对象
Joi.validate({username: 'abc'}, schema);
```

```
经常采用异步验证
async function () {
	try {
		await Joi.validate({username: 'abc'}, schema);
	} catch(ex) {
		console.log(ex);
		return;
	}
	console.log('验证通过');
}
```

#### 6.15 查询数据库的总用户量

```
let count = await User.countDocuments({});
```

#### 6.16  数据分页

```
数据库查询条件
limit(2) // limit限制查询数量 传入每页是的数据数量
skip(1) // skip跳过多少条数据 传入每页显示的页数
```

#### 6.17 文件上传

```
form表单属性
                entype 指定表单数据的编码类型
                默认 application/x-www-form-urlencoded
                因为文件上传以二进制上传所以表单编码为二进制类型
                设置为 multipart/form-data
```

#### 6.18 第三方模块 formidable 解析表单

```
作用： 解析表单 支持get请求参数 支持post请求参数 支持文件上传
```

```
// 引入formidable模块
const formidable = require('formidable');
// 创建表单解析对象
const form = new formidable.IncomingForm();
//设置文件上传路径
form.uploadDir = "/my/dir";
// 是否保留表单上传文件的扩展名 常设置true
form.keepExtensions = true;
//对表单进行解析
form.parse(req, (err, fields, files) => {
	// err 文件解析失败 的错误对象 成功为null
	// fields 存储普通请求参数
	// files 存储上传的文件信息
});
```

#### 6.19 js中文件读取 FileReader

```
// 获取表单控件
var file = querySelector('#file');
file.onchange = function () {
   // 创建文件对象
    var reader = new FileReader();
    // 读取文件 
    reader.readAsDataURL(this.files[0]);
    reader.onload = function () {
        console.log(reader.result);
    }
}

```

#### 6.20 数据分页模块 mongoose-sex-page

```
const pagination = require('mongoose-sex-page');
pagination(集合构造函数).page(1).size(20).display(8).exec();
```

```
查询返回一个对象
{
	"page": 1, // 当前页
	"size": 2, // 每页显示数据条数
	"total": 8, // 总共的数据的条数
	"records": [
		// 查询出来的具体数据 以对象的形式呈现
		{
			"_id": "34435436547",
			"title": 'wewe',
			.
			.
			.
		}
	],
	"pages": 4, // 总共的页数
	"dispaly": [1, 2, 3, 4] //客户端显示的页码
}
```

#### 6.21 mongoDB数据库添加账号

```
1. 以系统管理员的方式运行 powershell
2. 连接数据库 mongo
3. 查看数据库 show dbs
4. 切换到admin 数据库 use admin
5. 创建超级管理员账户 db.createUser({user: '',pwd: '', roles: ['root']})
6.切换到blog数据 use blog
7.创建普通账号 db.createUser({user: '', pwd: '',roles['readWrite']})
8. 卸载mongodb服务
	1. 停止 net stop mongodb
	2. mongod --remove
9. 创建mongoodb服务
	mongod --logpath="c:\Program File\MongoDB\Server\4.1\log\mongod.log" --dapath="c:\Program File\MongoBD\Server\4.1\data" --install -auth
10. 启动 mongodb 服务 net start mongodb
11. 在项目中使用账号连接数据库
mongoose.connect('mongdb://user:pass@localhost:port/database')
```

#### 6.22 开发环境与生产环境

```
通过电脑操作系统中的环境变量区分当前是开发环境还是生产环境
设置变量名 NODE_ENV
设置变量值 development 开发环境  production 生产环境
```

```
在代码中区分生产环境和开发环境
if (process.env.NODE_ENV == 'development') {
	// 开发环境
} else {
	// 生产环境
}
```

#### 6.23 第三方模块 morgan

```
 const morgan = require('morgan');
 if (process.env.NODE_ENV == 'development') {
	// 开发环境
	// 在开发环境中 将客户端发送到客户端的请求信息打印到控制台
	app.use(morgan('dev'));
} else {
	// 生产环境
}
```

#### 6.24 第三方模块 config

```
作用：允许开发人员将不同环境下发应用配置信息抽离到单独的文件中，模块内部自动判断当前应用的运行环境，并读取对应的配置信息，极大提供应用配置信息的维护成本， 手动到项目代码中修改配置信息
```

```
使用步骤
1. 使用 npm install config命令下载模块
2. 在项目的根目录下建立config文件夹
3. 在config文件夹下面建立 default.json development.json production.json文件
4. 在项目中通过require方法 将模块进行导入
	const config = require('config');
5. 使用模块内部提供的get方法获取配置信息
	config.get('title'); // 根据环境获取config文件夹下面的title属性值 在开发环境中读取 	   		development.json 在生产环境中读取production.json 文件 在开发 和生产环境中都没有时读取	 		default.json
```

#### 将敏感信息存储在环境变量中

```
1. 在config文件夹中建立custom-environment-variables.json文件
2. 配置项属性的值填写环境变量的名字
3. 项目运行时config模块查找环境变量，并读取其值作为当前配置项属性的值
在文件中写{
	"db": {
		"pwd": "APP_PWD" // 其实就是环境变量的值
	}
}
在系统环境中配置
变量名 APP_PWD
变量值： itcast
```

### 7. Ajax

```
在传统网站中存在的问题
网速慢的情况下，页面加载时间长，用户只能等待
表单提交后，如果一项内容不合格，需要重新填写所有表单内容
页面跳转，重新加载页面造成资源浪费，增加用户等待时间
```

```
ajax是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站应用的体验
```

```
Ajax的应用场景
1. 页面上拉加载更多数据
2. 列表数据无刷新分页
3. 表单项离开焦点数据验证
4. 搜索框提示文字下拉列表
```

#### 7.1 Ajax运行原理

```
浏览器端  创建 Ajax ajax向服务器发送请求
服务器 响应给ajax ajax响应给浏览器
```

#### 7.2 Ajax的实现步骤

```
1. 创建Ajax对象
var xhr = new XMLHttpRequest();
2. 告诉Ajax请求方式和请求地址
 	参数1 请求方式
 	参数2 请求路由
xhr.open('get', 'http://www.example.com');
3.发送请求
xhr.send();
4. 获取服务器端给予客户端的数据响应
xhr.onload = function() {
	// xhr.responseText 获取服务器端响应客户端的数据 
	console.log(xhr.responseText);
}
```

#### 7.3 JSON.parse()

```
JSON.parse() 将json字符串转换为json对象
```

#### 7.3 ajax中get请求参数

```
var params = 'username=' + 参数 + '&password=' + 参数;
xhr.open('get', 'http://www.example.com?' + params);
```

#### 7.4 ajax中post请求参数

```
var params = 'username=' + 参数 + '&password=' + 参数;
// 设置请求头 (设置请求参数的类型)
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
// 发送请求
xhr.send(params);
```

#### 7.5 post请求参数的格式

```
// 1. application/x-www-form-urlencoded
 参数格式 name=zhangsan&age=23
// 2.application/json
 参数格式 {name: "zhangsan", age: "23"}
 注意：在请求头中设置Content-Type的值为 application/json
 	  xhr.setRequestHeader('Content-Type', 'application/json');
 	  参数传递只能传字符串 所以把json对象数据格式转换为字符串 采用 JSON.stringify();
 	  xhr.send(JSON.stringify({name: "zhangsan", age: "23"}));
 	  
 	  在服务器端接收json数据 可以采用body-parser模块
 	  但是要设置数据格式
 	  app.use(bodyParser.json());
 	  然后接收参数
 	  req.body
注意： get请求不能提交json请求数据 传统网站表单请求也不能提交json参数请求
```

#### 7.6 另一种获取服务端的数据（Ajax状态码）

```
0: 请求未初始化（还未调用open()）
1: 请求已建立，但是还没有发送(还没有调用send())
2:请求已发送
3: 请求正在处理，通常响应中已有部分数据可以使用了
4: 响应已经完成，可以获取并使用服务器端的响应了
xhr.readyState // 获取Ajax的状态码
onreadystatechange事件 当Ajax状态码发生变化时自动触发该事件
```

```
// 1.创建ajax对象
var xhr = new XMLHttpRequest();
// 2.准备发送
xhr.open('post', 'http://localhost:3000/readyState');
// 3.发送
xhr.send();
// 4. 通过判断状态发获取服务器端数据 触发状态码改变事件
xhr.onreadystatechange = function () {
	if (xhr.readyState == 4) {
		console.log(xhr.responseText);
	}
}
```

#### 7.7 Ajax错误处理

```
1. 网络畅通，服务器端能接收到请求，服务器端返回的不是预期的结果
    可以判断服务器返回的状态码，分别进行处理， xhr.tatus获取http状态码
2. 网络畅通，服务器端没有接收到请求，返回404状态码
	检查请求地址是否错误
3. 网络畅通，服务器端接收到请求，服务器端返回500状态码
	服务器段错误，找后端程序员进行沟通
4. 网络中段， 请求无法发送到服务端
	不会触发onload事件， 会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理
```

#### 7.8 低版本IE浏览器的缓存问题

```
问题： 在低版本的IE浏览器中，Ajax请求有严重的缓存问题，既在请求地址不发生变化的情况下，只有第一次请求会正真发送到服务器端，后续的请求都会从浏览器的缓存中获取结果，即使服务器端的数据更新了，客户端依然拿到到的是缓存中的旧数据

决解方案： 在请求地址的后面加请求参数， 保证每一次请求中的请求参数的值不同
	xhr.open('get', 'http://www.example.com?t=' + Math.random());
```

#### 7.9 封装Ajax

```javascript
 function ajax(options) {
            // 设置对象的默认参数
           var defaults = {
                type: 'get',
                url: '',
                data: {},
                header: {
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                success: function () {},
                error: function () {}
            }
            // 调用对象的方法覆盖对象
            Object.assign(defaults, options);
            // 创建ajax对象
            var xhr = new XMLHttpRequest();
            // 定义拼接参数字符串
            var params = '';
            // 循环data对象拼接参数
            for (var attr in defaults.data) {
                params += attr + '=' + defaults.data[attr] + '&';
            }
            // 截取字符串去掉最后一个&符号
            params = params.substr(0, params.length - 1);
            if (defaults.type == 'get') {
                // 配置ajax
                xhr.open(defaults.type, defaults.url + '?' + params);
            }
            if (defaults.type == 'post') {
                var contentType = defaults.header['Content-Type'];
                // 配置ajax
                xhr.open(defaults.type, defaults.url);
                // 设置请求头
                xhr.setRequestHeader('Content-Type', contentType);
                if (contentType == 'application/json') {
                    xhr.send(JSON.stringify(defaults.data));
                } else {
                    xhr.send(params); 
                }  
            } else {
                // 发送
                xhr.send();
            }
            // 接受客户端参数
            xhr.onload = function () {
                // 获取服务器端响应头的数据类型
                var contentType = xhr.getResponseHeader('Content-Type');
                // 获取服务器端响应的数据
                var responseText = xhr.responseText;
                // 判断服务器端响应数据的类型是不是json数据类型
                if (contentType.includes('application/json')) {
                    // 将json数据类型转化为json对象
                    responseText = JSON.parse(responseText);
                }
                if (xhr.status == 200) {
                    // 服务器响应成功 
                    defaults.success(responseText, xhr);
                } else {
                    // 服务器端响应失败 
                    defaults.error(responseText, xhr)
                }     
            }
        }
```

#### 7.10  模板引擎

```
官方地址： https://aui.github.io/art-template/zh-cn/index.html
```

```
使用方法
1.下载art-template模块引擎库文件在HTML页面中引入库文件
	<script src="./js/template-web.js"></script>
2.准备art-template模板 设置模板的id 模板的类型
	<script id="tpl" type="text/html">
		4. 拼接模板与数据
		<h1>{{username}} {{age}}</h1>
	</script>
3.告诉模板引擎将哪一个模板和那个数据进行拼接
	<script>
		// 参数1 绑定的模板id 参数2 给模板传递的数据 对象类型
		// 返回一个拼接好的模板字符串
		var html = template('tpl', {username: 'zahngsan', age: '23'});
		5. 把模板字符串显示到页面
		document.getElementById('container').innerHTML = html;
	</script>
```

#### 7.11 FormDate 对象的作用

```
1. 模拟HTML表单，相当于将HTML表单映射成表单对象，自动将表单对象中的数据拼接成请求参数的格式
2. 异步上传二进制文件
3. 不能用于get请求
```

```
FOrmData对象的作用
1. 准备HTML表单
<form id="form">
	<input type="text" name="username">
	<input type="password" name="password">
	<input type="button">
</form>
2. 将HTML表单转化为 formdata对象
var form = document.getElementById('form');
var formData = new FormData(form);
3. 提交表单对象
xhr.send(formData);
```

```
服务器端使用 formidable模块解析数据
```

#### 7.12 FormData对象的实例方法 

```
1. 获取表单对象中的属性的值
formData.get('key');
2. 设置表单对象中属性的值
formData.set('age', 23);
3. 删除表单对象中属性的值
formData.delete('key');
4. 想表单对象中追加属性值
formData.append('key', 'value');
```

#### 7.13 FormData二进制文件上传

```
 // 获取表单
var file = document.querySelector('#file');
file.onchange = function () {
// 创建一个空的formdata表单对象
var formData = new FormData();
// 为空的表单对象追加一个文件属性
formData.append('attrName', this.files[0]);
// 创建ajax对象
var xhr = new XMLHttpRequest();
// 配置ajax
xhr.open('post', 'http://localhost:3000/upload');
// 发送
xhr.send(formData);
// 响应数据
xhr.onload = function () {
    if (xhr.status == 200 && xhr.readyState == 4) {
        console.log('ok');
    }
}
```

```
服务器端
app.post('/upload', (req, res) => {
	// 创建表单解析对象
	const form = new formidable.IncomingForm();
	// 配置文件上传的路劲
	form.uploadDir = path.join(__dirname, 'public', 'uploads');
	// 保留文件上传带后缀
	form.keepExtensions = true;
	// 解析表单
	form.parse(req, (err, fields, files) => {
		res.send(files);
	});
});
```

#### 7.14 FormData文件上传进度展示

```
// 当用户选择文件时
file.onchange = function () {
 // 文件上传中持续触发onprogress事件
 xhr.upload.onprogress = function (ev) {
 	// ev 事件对象
 	// ev.loaded 文件上传了的大小
 	// ev.total 文件总大小
 	bar.style.width = (ev.loaded / ev.totle) * 100 + '%';
 }
}
```

#### 7.15 FormData文件上传图片即时预览

```
在服务器获取文件的路径 attrName 文件上传的名字 由于文件路由时硬盘的绝对路由 切割路劲 获取静态文件夹后的路劲
res.send({
	path: files.attrName.path.split('public')[1]
})
在客户端 
 // 响应数据
xhr.onload = function () {
	if (xhr.status == 200 && xhr.readyState == 4) {
       // 接收服务器端传过来的路劲
       var result = JSON.parse(xhr.responseText);
       // 创建img标签
       var img = document.createElement('img');
       img.src = result.path;
       // 图片加载完成之后
       img.onload = function () {
       	// 把图片标签加入到图片容器中
       	box.appendChild(img);
       }
    }
}
```

#### 7.16 同源政策

```
如果两个页面拥有相同的协议、域名、端口、那么这两个页面就属于同一个源，其中只要有一个不相同，就是不同源
例如 ： http://www.example.com/dir/page.html

 http://www.example.com/dir2/other.html 同源
 http://example.com/dir/other.html 不同源 (域名不同)
 http://v2.www.example.com/dir/page.html 不同源（域名不同）
 http://www.example.com：81/dir/page.html 不同源 （端口不同）
 https://www.example.com/dir/page.html 不同源 （协议不同）
```

#### 7.17 使用JSONP解决同源限制问题

```
jsonp是json with padding 的缩写， 它不属于Ajax请求，但它可以模仿Ajax请求
```

```
1. 将不同源的服务器端的请求地址写在script标签的src属性中
    <script src="www.example.com"></script>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
2.服务器端响应数据必须是一个函数的调用，正真要发送给客户端的数据需要作为函数调用的参数
    const data = 'fn({name: '张三'， age: '20'})';
    res.send(data);
3.在客户端全局作用域下定义函数fn 要写在script的最上面
    function fn(data) {}
4.在fn函数内部对服务器端返回的数据进行处理
	function fn(data) {console.log(data);}
```

#### 7.18 jsonp封装

```
// 封装jsonp
function jsonp(options) {
     // 为回调函数生成一个随机函数名
     var fnName = 'myJson' + Math.random().toString().replace('.','');
     // 把回调函数挂在window下变成全局函数
     window[fnName] = options.success;
     // 定义一个拼接参数字符串
     var params = '';
     for (var attr in options.data) {
    	params += '&' + attr + '=' + options.data[attr];
     }
     // 创建script标签
     var script = document.createElement('script');
     script.src = options.url + '?callback=' + fnName + params;
     // 将script标签添加到页面
     document.body.appendChild(script);
     // 删除script标签
     script.onload = function () {
     	document.body.removeChild(script);
     }
 } 
```

```
在服务器有res下一个jsonp方法接收jsonp请求
app.get('/better', (req, res) => {
	// // 接收客户端传递过来的函数的名称
	// const fnName = req.query.callback;
	// // 将函数名称对应的函数调用代码返回给客户端
	// const data = JSON.stringify({name: "张三"});
	// const result = fnName + '('+ data +')';
	// res.send(result);
	// // setTimeout(() => {
	// // 	res.send(result);
	// // }, 1000)
	
	// jsonp方法在内部完成以上步骤
	res.jsonp({name: 'lisi', age: 20});
});

```

#### 7.19  CORS 跨域资源共享

```
CORS 全称Cross-origin resource sharing 既跨域资源共享，它允许浏览器向跨域服务器发送Ajax请求， 克服了ajax只能同源使用的限制
```

```
浏览器端  发送请求 带请求头（origin） 服务器端
服务器端  响应 响应头 （Access-Control-Access-Origin） 浏览器端
```

```
origin: http://localhost:3000
Access-Control-Allow-Origin', '*' 所有都可以访问
Access-Control-Allow-Origin', 'http://localhost:3000' 只允许这个网站访问
```

```
在服务器端
// 拦截所有请求
app.use((req, res, next) => {
	// * 代表允许所有的客户端访问
	res.header('Access-Control-Allow-Origin', '*');
	// 允许客户端使用那些请求方式访问
	res.header('Access-Control-Allow-Methods', 'get,post');
	next();
})
```

#### 7.20 在服务器端进行跨域请求 利用node的三方模块request

```
同源政策是浏览器给予Ajax技术的限制，服务器端是不存在同源政策的限制的
a浏览器 发送请求 a服务器
a服务器 发送请求 b服务器
b服务器 响应 a服务器
a服务器 响应 a浏览器
```

```
在客户端利用node第三方模块 request模块 
request作用： 向其他服务器发送请求 并接受参数
使用
下载 npm install request
request('http://localhost:3001/request', (error, response, body) => {
	// 参数一： 要访问点服务器地址
	// 参数二： 回调函数
	// error 错误对象 没错误 返回null
	// response 返回响应的一些信息
	// body 返回响应主体 正真的响应数据参数
	res.send(body);
});
```

#### 7.21 在跨域请求中解决cookie问题 withCredentials属性

```
在私用ajax技术发送跨域请求时，默认情况在不会在请求中携带cookie信息
解决方法： 
	在客户端的ajax请求中的xhr的属性下有一个 withCredentials 属性 是否携带cookie信息 默认值为false 不携带
	xhr.withCredentials = true;
	在服务器端请求头中设置 但是必须在客户端指定访问的地址 不能是 *
	res.header('Access-Control-Allow-Origin', 'http://localhost:3000');
	res.header('Access-Control-Allow-Credentials', 'true'); // 允许客户端发送请求时携带cookie
```

### 8. jquery中的ajax

```
$.ajax({
	// 请求方式 get  post
	type: 'get',
	// 请求地址 在同源请求时可省略协议 域名 端口 直接写/text
	url: 'http:www.example.com/text',
	// 参数 也可以直接使用&符号拼接 data: 'name=zhangsan&age=23'
	data: {name: 'zhangsan', age: '23'}
	// 参数格式 'application/json' json数据格式  'application/x-www-form-urlencoded' &拼接
	contentType: 'application/x-www-form-urlencoded',
	beforeSend: function () {
		// 在发送之前执行 一般用来做参数符合验证 不符合 return false 阻止执行
		return false;
	},
	success: function (data) {
		console.log(data);
	},
	error: function (xhr) {
		console.log(xhr);
	}
})
```

#### 8.1  jquery中的serialize()方法 拼接表单参数

```
作用: 将表单内容拼接成字符串的类型参数
var params = $('#form').serialize();
// 序列化表单参数 name=zhangsan&age=123
var params = $('#form').serializeArray();
// 序列化表单参数为 [{name: 'name', value: 'zahngsan'},{name: 'age', value: '123'}]
```

```
自己封装一个函数将表单参数转换为对象类型
function serializeObject(obj) {
	// 序列化表单 [{name: 'name', value: 'zahngsan'},{name: 'age', value: '123'}]
	var params = obj.serializeArray();
	//定义一个空对象
	var result = {}
	// 循环数组 转换为对象类型 {name: 'zhangsan', age: '123'}
	$.each(params, (index, value) => {
		result[value.name] = value.value;
	});
	// 返回对象
	return result;
}
```

```
serializeObject($('#form'));
```

#### 8.2 $.ajax（）方法jsonp

```
$.ajax({
	url: 'http://www.example.com',
	// 指定当前发送jsonp请求
	dataType: 'jsonp',
	// 修改callback参数名称
	jsonp: 'cb',
	// 指定函数名称
	jsonpCallback: 'fnName',
	success: function (response) {
		console.log(response);
	}
});
```

#### 8.3 $.get() $.post()方法

```
发送get post请求
// 参数一请求地址
// 参数二请求参数 可选
// 参数三 回调函数 返回响应结果
$.get('http:///www.example.com', {naem: 'zhangsan', age: 23}, function (response) {
	console.log(response);
})

$.post('http:///www.example.com', {naem: 'zhangsan', age: 23}, function (response) {
	console.log(response);
})
```

#### 8.4 jQuery中Ajax全局事件

```
只要页面中有Ajax请求被发送时，对应的全局事件就会被触发
.ajaxStart() // 当请求开始发送时触发
.ajaxComplete(); //当请求完成是触发
注意 这两个事件只能绑定在document元素上
$(document).on('ajaxStart', function () {

})
$(document).on('ajaxComplete', function () {

})
```

#### 8.5 NProgress 纳米级进度条插件

```
<link rel="stylesheet" href="nprogress.css">
<script src="nprogress.js"> </srcipt>
调用方法
 NProgress.start()； //进度条开始运动
 NProgress.done(); // 进度条结束运动
 
 网址 http://ricostacruz.com/nprogress/
```

### 9. RESTful风格的API

```
一套关于设计请求的规范
GET:获取数据
POST: 添加数据
PUT: 更新数据
DELETE: 删除数据
put delete 请求只能在Ajax中使用
请求地址要与数据库集合对应
users => /users
articles => /articles

GET : http://www.example.com/users 获取用户列表数据
POST : http://www.example.com/users 创建添加用户数据
GET : http://www.example.com/users/1 获取用户ID为1的用户信息
PUT : http://www.example.com/users/1 修改用户ID为1的用户信息
DELETE : http://www.example.com/users/1 删除用户ID为1的用户信息
```

```
示例
在客服端
$.ajax({
	type: 'put',            // 更新数据请求
	url: '/users/1',     // 更新用户id为1的用户
	success: function () {
		
	}
})
在服务器端
app.put('/user/:id', (req, res) => {
	// 解析参数
	const id = req.params.id;
	res.send(`更新用户的id为${id}`);
});
```

